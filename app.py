
from flask import Flask, render_template, session, url_for, request, redirect
import pymysql
import json

app = Flask(__name__)
app.secret_key = 'sample_secret'

# DB Connect Config


def connectsql():
    conn = pymysql.connect(host='DB_HOST', user='DB_USER',
                           passwd='DB_PASSWORD', db='vsrd_result', charset='utf8')
    return conn


@app.route('/')
def post():
    # DB connection
    conn = connectsql()
    cursor = conn.cursor(pymysql.cursors.DictCursor)

    # 진단 결과를 역순으로 SELECT 합니다.
    query = "SELECT * FROM result ORDER BY id DESC"
    cursor.execute(query)
    result = cursor.fetchall()
    id = []

    # DB에 진단 결과가 Json Type으로 저장되어 있습니다.
    # 따라서, 각 데이터를 분리시키는 과정입니다.
    for i, result_list in enumerate(result):
        result[i] = result_list.get('result')
        result[i] = result[i].lstrip('{')
        temp = result_list.get('id')
        temp = '{"id": "'+str(temp)+'", '
        result[i] = temp+result[i]
        result[i] = eval(str(result[i]))

    # DB connection Close
    cursor.close()
    conn.close()

    # 결과 리턴
    return render_template('post.html', resultlist=result, id=id)


@app.route('/result/<id>')
def content(id):
    # DB Connection
    conn = connectsql()
    cursor = conn.cursor(pymysql.cursors.DictCursor)

    # 선택한 ID의 진단 결과 데이터를 불러옵니다.
    query = "SELECT * FROM result WHERE id = %s"
    value = id
    cursor.execute(query, value)
    result = cursor.fetchall()

    # 아래의 List로 구성된 진단 항목, 중요도, 설명은 Dictionary로 구성했으면 좋았을 것 같습니다.
    # 취약점 진단 항목입니다.
    check_list = [
        "디폴트 계정 삭제",
        "root 권한 관리",
        "passwd 파일 권한 설정",
        "group 파일 권한 설정",
        "패스워드 사용규칙 적용",
        "Shell 제한",
        "su 제한"
    ]

    # 취약점별 중요도입니다.
    check_importance = [
        "중",
        "상",
        "상",
        "상",
        "중",
        "중",
        "중"
    ]

    # 취약점 진단 항목별 설명입니다.
    check_criteria = [
        "/etc/passwd 파일에서 시스템에 사용되지 않는 Default 계정이 삭제되어 있는지",
        "/etc/passwd 파일에서 root 이외의 계정에 UID가 0으로 설정되어 있는지",
        "/etc/passwd 파일의 권한이 644 이하로 설정되어 있는지",
        "/etc/group 파일의 권한이 644 이하로 설정되어 있는지",
        "패스워드 최소길이: 8자 이상\n패스워드 최대 사용기간: 70일 이하\n패스워드 최소 사용기간: 7일 이상",
        "/etc/passwd 파일에서 접근이 필요하지 않은 계정에 쉘 제한이 되어 있는지",
        "/etc/pam.d/su 파일에서 su 권한을 whell 그룹만 사용할 수 있도록 설정되어 있는지"
    ]

    # DB에 진단 결과가 Json Type으로 저장되어 있습니다.
    # 따라서, 각 데이터를 분리시키는 과정입니다.
    for i, result_list in enumerate(result):
        result[i] = result_list.get('result')
        result[i] = result[i].lstrip('{')
        temp = result_list.get('id')
        temp = '{"id": "'+str(temp)+'", '
        result[i] = temp+result[i]
        result[i] = eval(str(result[i]))
        print(i, "번째 진단 결과가 정렬되었습니다.", sep="\n")
        #print(i,"번째 상세 결과: ",result[i], sep="\n")

    conn.commit()

    # DB Connection Close
    cursor.close()
    conn.close()

    return render_template('content.html', data=result, check_list=check_list, check_importance=check_importance, check_criteria=check_criteria)


@app.route('/upload', methods=['POST'])
def upload():
    if request.method == 'POST':
        print("Upload Start")
        # Post Method로 전송된 Json Type 데이터를 저장합니다.
        result = request.get_json(cache=False, force=True)

        # 받아온 데이터를 Json Type으로 다시 인코딩 합니다.
        result = json.dumps(result)

        print("Upload Result: ", result)

        # DB Connection
        conn = connectsql()
        cursor = conn.cursor()

        # 취약점 진단 결과를 DB에 저장합니다.
        cursor.execute("INSERT INTO result(result) values (%s)", result)
        conn.commit()

        # DB Connection Close
        cursor.close()
        conn.close()
        return "클라우드 데이터베이스에 결과 저장이 완료되었습니다."


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80, debug=False)
